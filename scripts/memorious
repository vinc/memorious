#!/usr/bin/env python
#
# Copyright (C) 2010 Vincent Ollivier <contact@vincentollivier.com>
#
# This file is part of Memorious.
#
# Memorious is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import argparse
import csv
import curses
import errno
import os
import sys
import stat

from getpass import getpass

from memorious.store import Store, Password, KeyFile

def check_permissions(path, mode):
    msg = "Warning: '%s' permissions should be changed from %d to %d\n"
    o = lambda x: int(oct(x)[2:])
    st_imode = stat.S_IMODE(os.lstat(path).st_mode)
    if not st_imode == mode:
        sys.stderr.write(msg % (path, o(st_imode), o(mode)))

def get_password(args):
    if args.password is None:
        password = str(Password.generate(args.password_length, args.secure))
        print('Your password is: %s' % password)
        return password
    elif args.password == '':
        return Password(getpass())
    else:
        return Password(args.password)

def get_width():
    window = curses.initscr()
    width = window.getmaxyx()[1]
    curses.endwin()
    return width

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Manage website accounts.')
    subparsers = parser.add_subparsers(help="try 'SUB-COMMAND --help'",
                                       dest='action')

    parser.add_argument('--memfile', default='~/.memorious/store.mem')
    parser.add_argument('--keyfile', default='/tmp/memorious.key')

    subparser = subparsers.add_parser('new', help='create a new key file')
    subparser.add_argument('--key-size', default=256, type=int)
    subparser.add_argument('--file-size', default=1024, type=int)

    subparser = subparsers.add_parser('get', help='get stored accounts')
    subparser.add_argument('--domain', default='')
    subparser.add_argument('--username', default='')
    subparser.add_argument('--comment', default='', nargs='*')
    subparser.add_argument('--csv', action='store_true')

    subparser = subparsers.add_parser('put', help='store a new account')
    subparser.add_argument('--domain', default='')
    subparser.add_argument('--username', default='')
    subparser.add_argument('--comment', default='', nargs='*')
    subparser.add_argument('--password', nargs='?', const='')
    subparser.add_argument('--password-length', default=16)
    subparser.add_argument('--secure', action='store_true')

    subparser = subparsers.add_parser('del', help='delete stored accounts')
    subparser.add_argument('ids', nargs='+')

    args = parser.parse_args()

    mem_file = os.path.expanduser(args.memfile)
    if os.path.isfile(mem_file):
        check_permissions(mem_file, 0o600)

    key_file = os.path.expanduser(args.keyfile)
    if os.path.isfile(key_file):
        check_permissions(key_file, 0o400)

    if args.action == 'new':
        # Create a new key file for a new database
        try:
            KeyFile.generate(key_file, args.key_size, args.file_size)
        except IOError as e:
            if e.errno == errno.EEXIST:
                sys.stderr.write('%s\n' % e.strerror)
                sys.exit(errno.EEXIST)
            else:
                raise
        print("Key file successfully created at '%s'." % key_file)
        print("Store it somewhere safe and don't lose it!")
        os.makedirs(os.path.dirname(mem_file), 0o700)
        sys.exit()

    data = {}
    if 'domain' in args and args.domain is not None:
        data['domain'] = args.domain
    if 'username' in args and args.username is not None:
        data['username'] = args.username
    if 'comment' in args and args.comment is not None:
        data['comment'] = ' '.join(args.comment)

    try:
        with Store.open(mem_file, key_file) as store:
            if args.action == 'get': # Get accounts stored in the database
                # Construct a dictionary for the results
                keys = ['id', 'domain', 'username', 'password', 'comment']
                res = dict(zip(keys, ([k.title() + 's'] for k in keys)))

                # Execute the query and fetch the results
                accounts = list(store.get(**data))
                if not accounts:
                    sys.exit('No results.')
                for row in accounts:
                    for k in keys:
                        res[k].append(str(row[k]))

                if args.csv:
                    writer = csv.writer(sys.stdout)
                    for i in range(len(res['id'])):
                        writer.writerow([res[k][i] for k in keys])
                    sys.exit()

                # Get the window's width
                width = get_width()

                # Divide the space between each column to fill the window
                lcols = dict(zip(keys, (max(map(len, res[k])) for k in keys)))
                while sum(lcols.values()) + len(keys) * 2 - 2 > width:
                    lcols[max(zip(lcols.values(), lcols.keys()))[1]] -= 1

                # Print the table
                for i in range(len(accounts) + 1):
                    print('  '.join(res[k][i].ljust(lcols[k]) for k in keys))
                    if not i:
                        print('-' * (sum(lcols.values()) + len(keys) * 2 - 2))

            elif args.action == 'put': # Put a new account in the database
                if not data:
                    parser.print_help()
                    sys.exit()

                # Get or generate the account's password
                data['password'] = get_password(args)

                # Put account information in database
                store.put(**data)

            elif args.action == 'del': # Remove an account from the database
                for id in args.ids:
                    store.delete(id)

    except IOError as e:
        if e.errno == errno.ENOENT:
            sys.stderr.write('%s\n' % e.strerror)
            sys.exit(errno.ENOENT)
        else:
            raise
